# cython: language_level=3
cimport cython
cimport numpy as cnp
import numpy as np
from cython cimport view
from warnings import warn
from libc.stdlib cimport malloc, free
from libc.math cimport isfinite
from scipy.linalg import LinAlgError, LinAlgWarning
from scipy.linalg.cython_lapack cimport (slamch, dlamch,
                                         sgetrf, dgetrf, cgetrf, zgetrf,
                                         sgetrs, dgetrs, cgetrs, zgetrs,
                                         sgecon, dgecon, cgecon, zgecon,
                                         strtrs, dtrtrs, ctrtrs, ztrtrs,
                                         slange, dlange, clange, zlange,
                                         strcon, dtrcon, ctrcon, ztrcon,
                                         spotrf, dpotrf, cpotrf, zpotrf
                                        )

{{py:

typenames = ['float', 'double', 'float complex', 'double complex']
typenames_scdz = ['float', 'double', 'float', 'double']
prefixes = ['s', 'd', 'c', 'z']

}}

__all__ = ['get_lapack_flavor', 'array_is_finite', 'find_array_structure',
           'lusolve', 'diagsolve', 'trisolve', 'bidiagsolve']

ctypedef fused lapack_t:
    float
    double
    (float complex)
    (double complex)

ctypedef fused lapack_cz_t:
    (float complex)
    (double complex)

ctypedef fused lapack_sd_t:
    float
    double

ctypedef fused lapack_f_t:
    float
    (float complex)
ctypedef fused lapack_d_t:
    double
    (double complex)

ctypedef (int, int) (*f_tri_ptr)(lapack_t[:, ::1]) nogil
ctypedef (bint, bint) (*f_sym_ptr)(lapack_t[:, ::1]) nogil
ctypedef int (*f_posdiag_ptr)(lapack_t[:, ::1]) nogil


# The numpy facilities for type-casting checks are too slow for small sized
# arrays and eats away the time budget for the checkups. Here we provide a
# precomputed version of the numpy.can_cast() table.

# output of np.typecodes['All']
cdef str casting_key = '?bhilqpBHILQPefdgFDGSUVOMm'

#                          f  d  F  D
casting_table = np.array([[1, 1, 1, 1],  # ?
                          [1, 1, 1, 1],  # b
                          [1, 1, 1, 1],  # h
                          [0, 1, 0, 1],  # i
                          [0, 1, 0, 1],  # l
                          [0, 1, 0, 1],  # q
                          [0, 1, 0, 1],  # p
                          [1, 1, 1, 1],  # B
                          [1, 1, 1, 1],  # H
                          [0, 1, 0, 1],  # I
                          [0, 1, 0, 1],  # L
                          [0, 1, 0, 1],  # Q
                          [0, 1, 0, 1],  # P
                          [1, 1, 1, 1],  # e
                          [1, 1, 1, 1],  # f
                          [0, 1, 0, 1],  # d
                          [0, 1, 0, 1],  # g
                          [0, 0, 1, 1],  # F
                          [0, 0, 0, 1],  # D
                          [0, 0, 0, 1],  # G
                          [0, 0, 0, 0],  # S
                          [0, 0, 0, 0],  # U
                          [0, 0, 0, 0],  # V
                          [0, 0, 0, 0],  # O
                          [0, 0, 0, 0],  # M
                          [0, 0, 0, 0]],  # m
                         dtype=bool)


@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cpdef int get_lapack_flavor(str a, str b, str K = casting_key,
                            const cnp.npy_bool[:, ::1]C = casting_table):
    cdef int ind
    cdef size_t rowa = K.find(a)
    cdef size_t rowb = K.find(b)
    if rowa == -1 or rowb == -1:
        raise TypeError('Data type is not known to NumPy.')

    for ind in range(4):
        if C[rowa, ind] and C[rowb, ind]:
            return ind

    return -1


@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cpdef bint array_is_finite(lapack_t[:, ::1]A) nogil:
    """
    Runs over the array and checks for infs and nans. Compared
    to asarray_chkfinite the performance gets better as the
    array size increases. Starting from n=3 it is ~x2 faster
    for finite arrays and faster if array has inf/nan due to
    early exit capability.
    """
    cdef int n = <int>A.shape[0]
    cdef int r, c
    cdef lapack_t entry
    if lapack_t in lapack_cz_t:
        for r in xrange(n):
            for c in xrange(n):
                entry = A[r, c]
                if not(isfinite(entry.real) and isfinite(entry.imag)):
                    return False
    else:
        for r in xrange(n):
            for c in xrange(n):
                if (not isfinite(A[r, c])):
                    return False
    return True


@cython.boundscheck(False)
@cython.wraparound(False)
cdef inline bint _ones_on_diagonal(lapack_t[:, ::1] a) nogil:
    cdef size_t n = len(a)
    cdef int k
    cdef lapack_t one = 1.0

    for k in range(n):
        if a[k, k] != one:
            return False

    return True


@cython.boundscheck(False)
@cython.wraparound(False)
cdef (int, int) _is_tri_c(lapack_t[:, ::1]A) nogil:
    """
    Computes the lower and the upper band width of a square
    matrix. If both bands are zero, it's diagonal, if either
    is zero then lower/upper triangular etc. If all entries
    are full then for nxn matrix the result is (n-1, n-1).

    This is the row-major layout version (C-contiguous).
    """
    cdef size_t n = A.shape[0]
    cdef int r, c, lower_band, upper_band
    lower_band = 0
    upper_band = 0
    for r in xrange(n):
        for c in xrange(n):
            # Only bother if outside the existing band:
            if (A[r, c] != 0.):
                if r > c and (r - c) > lower_band:
                    lower_band = r - c
                elif r < c and (c - r) > upper_band:
                    upper_band = c - r

    return lower_band, upper_band


@cython.boundscheck(False)
@cython.wraparound(False)
cdef (bint, bint) _is_sym_her_c(lapack_t[:, ::1]A) nogil:
    """
    Checks for the symmetry or Hermitianness for a square matrix.
    For reals it doesn't matter however for complex matrices,
    symmetry can still be exploited even though the matrix is not
    Hermitian.
    """
    cdef size_t n = A.shape[0]
    cdef int r, c
    cdef lapack_t x, y
    cdef bint symmetric = 1
    cdef bint hermitian = 1

    # Real branch
    if lapack_t in lapack_sd_t:
        for r in xrange(n):
            for c in xrange(n):
                if r == c:
                    continue
                else:
                    if A[r, c] != A[c, r]:
                        return 0, 0
        return 1, 1
    # Complex branch
    else:
        for r in xrange(n):
            for c in xrange(n):
                # look-up once
                x, y = A[r, c], A[c, r]
                # once caught no need to keep checking continue for sym
                if hermitian:
                    if x != y.conjugate():
                        hermitian = 0

                if x != y:
                    symmetric = 0

                if not (symmetric or hermitian):
                    return 0, 0

        return hermitian, symmetric


@cython.boundscheck(False)
@cython.wraparound(False)
cdef int _is_posdef_diag_c(lapack_t[:, ::1]A) nogil:
    cdef size_t n = A.shape[0]
    cdef int d
    cdef bint pos

    # Real branch
    if lapack_t in lapack_sd_t:
        if A[0, 0] == 0:
            return 0
        pos = A[0, 0] > 0

        for d in xrange(1, n):
            if (A[d, d] > 0) ^ pos:
                return 0
    else:
        if A[0, 0].real == 0:
            return 0
        pos = A[0, 0].real > 0

        for d in xrange(1, n):
            if (A[d, d].real > 0) ^ pos:
                return 0

    return 1 if pos else 2


@cython.boundscheck(False)
@cython.wraparound(False)
cpdef (int, int) find_array_structure(lapack_t[:, ::1]A) nogil:
    """
    Returns (family, member) structure information given a square C-contiguous
    array.

    Family
    ------
    0 : no structure found (0: dummy member)
    1 : triangular (0: diagonal, 1: lower, 2: upper, 3: lower bi, 4: upper bi)
    2 : hessenberg (0: lower, 1: upper, 2: tridiag,)
    3 : hermitian (0: non-posdef, 1: maybe posdef, 2: maybe negdef)
    4 : complex symmetric (0: dummy member)

    """
    cdef int lb, ub
    cdef bint her, sym
    cdef f_tri_ptr tri_bands
    cdef f_sym_ptr sym_check
    cdef f_posdiag_ptr posdiag_check
    # Function pointers
    tri_bands = &_is_tri_c[lapack_t]
    sym_check = &_is_sym_her_c[lapack_t]
    posdiag_check = &_is_posdef_diag_c[lapack_t]

    # Triangular/Hess family
    lb, ub = tri_bands(A)

    if lb == 0 and ub == 0:
        return 1, 0  # diagonal
    elif lb == 0:
        if ub == 1:
            return 1, 4  # upper bidiagonal
        else:
            return 1, 1  # upper triangular
    elif ub == 0:
        if lb == 1:
            return 1, 3  # lower bidiagonal
        else:
            return 1, 2  # lower triangular

    if lb == 1 and ub == 1:
        return 2, 2  # tridiagonal
    elif lb == 1:
        return 2, 0  # lower hessenberg
    elif ub == 1:
        return 2, 1  # upper hessenberg

    # Sym/Her/PosDef family
    her, sym = sym_check(A)
    if her:
        # Note: realness of the diagonal is already checked
        return 3, posdiag_check(A)
    if sym:
        return 4, 0

    # No known structure return generic
    return 0, 0


# ########################
# internal ge functions
# ########################
{{for typename, typeprefix, typenamescdz in zip(typenames, prefixes, typenames_scdz)}}
@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cdef int lusolve_{{typeprefix}}(char* trans, char* norm, int* n, int* nrhs, int* info, ({{typename}}*) a, ({{typename}}*) b) nogil except -1:
    cdef int row = n[0]
    cdef {{typenamescdz}}* work = <{{typenamescdz}}*> malloc({{if typeprefix in ['s', 'd']}}4{{else}}2{{endif}}*row*sizeof({{typenamescdz}}))
    {{if typeprefix in ['c', 'z']}}
    cdef {{typename}}* cwork = <{{typename}}*> malloc(2*row*sizeof({{typename}}))
    {{endif}}
    cdef int* ipiv = <int *> malloc(row * sizeof(int))
    cdef {{typenamescdz}} anorm
    cdef {{typenamescdz}} rcond = 0.0
    {{if typeprefix in ['s', 'd']}}
    if not work or not ipiv:
        raise MemoryError("Internal array allocation failed.")
    {{else}}
    if not work or not ipiv or not cwork:
        raise MemoryError("Internal array allocation failed.")
    {{endif}}

    anorm = {{typeprefix}}lange(norm, n, n, a, n, work);
    {{typeprefix}}getrf(n, n, a, n, ipiv, info)
    if info[0] != 0:
        free(ipiv)
        free(work)
        {{if typeprefix in ['c', 'z']}}
        free(cwork)
        {{endif}}
        if info[0] > 0:
            raise LinAlgError('Matrix is singular')
        if info[0] < 0:
            raise LinAlgError('LAPACK routine {{typeprefix}}getrf reported an illegal value in {}-th argument.'.format(-info[0]))

    {{typeprefix}}getrs(trans, n, nrhs, a, n, ipiv, b, n, info)
    {{if typeprefix in ['c', 'z']}}
    free(ipiv)  # We are done with it anyways
    {{endif}}

    if info[0] != 0:
        free(work)
        {{if typeprefix in ['c', 'z']}}
        free(cwork)
        {{else}}
        free(ipiv)
        {{endif}}
        raise LinAlgError('LAPACK routine {{typeprefix}}getrs reported an illegal value in {}-th argument.'.format(-info[0]))

    {{if typeprefix in ['s', 'd']}}
    # Recycle ipiv as iwork
    {{typeprefix}}gecon(norm, n, a, n, &anorm, &rcond, work, ipiv, info);
    free(ipiv)
    {{else}}
    {{typeprefix}}gecon(norm, n, a, n, &anorm, &rcond, cwork, work, info);
    free(cwork)
    {{endif}}
    free(work)

    if info[0] != 0:
        raise LinAlgError('LAPACK routine {{typeprefix}}gecon reported an illegal value in {}-th argument.'.format(-info[0]))

    # recycle anorm for eps
    {{if typeprefix in ['s', 'c']}}
    anorm = slamch('E')
    {{else}}
    anorm = dlamch('E')
    {{endif}}
    if rcond < anorm:  # rcond < eps
        with gil:
            warn('Ill-conditioned matrix (rcond={:.6g}): result may not be accurate.'.format(rcond), LinAlgWarning)

    return 0


{{endfor}}


@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cpdef inline int lusolve(lapack_t[:, ::1] a,
                         lapack_t[::1, :]b,
                         bint a_is_c) nogil except -1:
    """
    LU solution is a straightforward call to two LAPACK
    routines first ?getrf and then ?getrs. Here to detect the
    ill-conditioned problems we squeeze a ?gecon call after
    getrf.

    Since A is in row-major order, we factorize A.T and use
    transposed version in getrs depending is a_is_c array or not.
    """
    cdef char* trans = 'T' if a_is_c else 'N'
    cdef char* norm = '1' if a_is_c else 'I'
    cdef int info, res
    cdef int n = <int>a.shape[0]
    cdef int nrhs = <int>b.shape[1]

    if lapack_t is float:
        res = lusolve_s(trans, norm, &n, &nrhs, &info, &a[0, 0], &b[0, 0])
    elif lapack_t is double:
        res = lusolve_d(trans, norm, &n, &nrhs, &info, &a[0, 0], &b[0, 0])
    elif lapack_t is floatcomplex:
        res = lusolve_c(trans, norm, &n, &nrhs, &info, &a[0, 0], &b[0, 0])
    else:
        res = lusolve_z(trans, norm, &n, &nrhs, &info, &a[0, 0], &b[0, 0])

    return res


# ########################
# internal diag function
# ########################
# Just a regular python func.
# Not optimized for its simple functionality
# TODO: optimize
def diagsolve(a, b):
    if any(a == 0.):
        raise LinAlgError("Matrix is singular")

    diags_abs = np.abs(a)
    diags_min = diags_abs.min()
    if diags_min == 0.:
        raise LinAlgError("Matrix is singular")
    rcond = diags_min/diags_abs.max()
    b /= a[:, None]

    if rcond <  np.finfo(a.dtype).eps:
        warn('Ill-conditioned matrix (rcond={:.6g}): '
              'result may not be accurate.'.format(rcond),
              LinAlgWarning)

    return b


# ########################
# internal tr functions
# ########################
{{for typename, typeprefix, typenamescdz in zip(typenames, prefixes, typenames_scdz)}}
@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cdef int trisolve_{{typeprefix}}(char* norm, char* uplo, char* diag, char* transa, int* n, int* nrhs, ({{typename}}*) a, ({{typename}}*) b) nogil except -1:
    cdef char* side = 'L'  # No XA = B for now
    cdef int row = n[0]
    cdef int info
    cdef {{typename}}* work = <{{typename}}*> malloc({{if typeprefix in ['s', 'd']}}3{{else}}2{{endif}}*row*sizeof({{typename}}))
    {{if typeprefix in ['s', 'd']}}
    cdef int* iwork = <int *> malloc(row * sizeof(int))
    {{else}}
    cdef {{typenamescdz}}* rwork = <{{typenamescdz}}*> malloc(row * sizeof({{typenamescdz}}))
    {{endif}}
    cdef {{typenamescdz}} eps = {{if typeprefix in ['s', 'c']}}s{{else}}d{{endif}}lamch('E')
    cdef {{typenamescdz}} rcond = 0.0

    {{if typeprefix in ['s', 'd']}}
    if not work or not iwork:
        raise MemoryError("Internal array allocation failed.")

    {{typeprefix}}trcon(norm, uplo, diag, n, a, n, &rcond, work, iwork, &info)
    free(iwork)
    {{else}}
    if not work or not rwork:
        raise MemoryError("Internal array allocation failed.")

    {{typeprefix}}trcon(norm, uplo, diag, n, a, n, &rcond, work, rwork, &info)
    free(rwork)
    {{endif}}
    free(work)

    if info < 0:
        raise LinAlgError('LAPACK routine {{typeprefix}}trcon reported an illegal value in {}-th argument.'.format(-info))
    if rcond < eps:
        with gil:
            warn('Ill-conditioned matrix (rcond={:.6g}): result may not be accurate.'.format(rcond), LinAlgWarning)

    {{typeprefix}}trtrs(uplo, transa, diag, n, nrhs, a, n, b, n, &info)
    if info < 0:
        raise LinAlgError('LAPACK routine {{typeprefix}}trtrs reported an illegal value in {}-th argument.'.format(-info))
    if info > 0:
        raise LinAlgError('Matrix is singular')

    return 0


{{endfor}}


@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
cpdef int trisolve(lapack_t[:, ::1] a, lapack_t[::1, :]b, bint a_is_c,
                   bint lower, bint transposed) nogil except -1:
    """
    TR solution is a straightforward call to ?trtrs routines.

    For the array transposition and upper/lower triangular side, truth table

                                   a_is_c
                              | True | False
                        ------|------|------
                        True  |  'U' |  'L'
                  lower ------|------|-------
                        False |  'L' |  'U'
    """
    cdef char* trans_r = 'T' if transposed else 'N'
    cdef char* trans_c = 'C' if transposed else 'N'
    cdef char* norm = '1' if a_is_c else 'I'
    cdef char* uplo = 'L' if (a_is_c ^ lower) else 'U'
    cdef char* diag = 'U' if _ones_on_diagonal(a) else 'N'
    cdef int res
    cdef int n = <int>a.shape[0]
    cdef int nrhs = <int>b.shape[1]

    if lapack_t is float:
        res = trisolve_s(norm, uplo, diag, trans_r, &n, &nrhs, &a[0, 0], &b[0, 0])
    elif lapack_t is double:
        res = trisolve_d(norm, uplo, diag, trans_r, &n, &nrhs, &a[0, 0], &b[0, 0])
    elif lapack_t is floatcomplex:
        res = trisolve_c(norm, uplo, diag, trans_c, &n, &nrhs, &a[0, 0], &b[0, 0])
    else:
        res = trisolve_z(norm, uplo, diag, trans_c, &n, &nrhs, &a[0, 0], &b[0, 0])

    return res


# ###########################
# internal bidiag functions
# ###########################
@cython.boundscheck(False)
@cython.wraparound(False)
@cython.nonecheck(False)
@cython.cdivision(True)
cpdef int bidiagsolve(lapack_t[::1] d,
                      lapack_t[::1] u,
                      lapack_t[::1, :] b,
                      bint lower) nogil except -1:
    """
    Only the diagonal and the sub/sup diagonal is passed. Substitution
    direction is controlled via the bool.

    b is in column major format so goes through the columns unlike every other
    textbook implementation.
    """
    # TODO: This might not be the optimal way to do it via memoryviews;
    # gather feedback and optimize. But it is already O(n) so would not
    # return huge benefits other than decreasing the constant.

    cdef int n = <int>b.shape[0]
    cdef int nrhs = <int>b.shape[1]
    cdef int r, c

    for r in xrange(n):
        if d[r] == 0.0:
            raise LinAlgError("Matrix is singular.")

    # forward substitution
    if lower:
        for c in xrange(nrhs):
            b[0, c] = b[0, c] / d[0]
            for r in range(1, n):
                b[r, c] = (b[r, c] - u[r-1]*b[r-1, c]) / d[r]
    else:
        for c in xrange(nrhs):
            b[n-1, c] = b[n-1, c] / d[n-1]
            for r in range(n-2, -1, -1):
                b[r, c] = (b[r, c] - u[r]*b[r+1, c]) / d[r]

    return 0
